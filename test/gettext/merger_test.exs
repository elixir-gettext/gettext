defmodule Gettext.MergerTest do
  use ExUnit.Case, async: true

  alias Expo.Message
  alias Expo.Messages
  alias Gettext.Merger

  @opts fuzzy: true, fuzzy_threshold: 0.8
  @autogenerated_flags [["elixir-format"]]
  @pot_path "../../tmp/" |> Path.expand(__DIR__) |> Path.relative_to_cwd()

  describe "merge/2" do
    test "headers from the old file are kept" do
      old_po = %Messages{
        headers: [~S(Language: it\n), ~S(My-Header: my-value\n)],
        messages: []
      }

      new_pot = %Messages{headers: ["foo"], messages: []}

      assert {new_po, _stats} = Merger.merge(old_po, new_pot, "en", @opts)
      assert new_po.headers == old_po.headers
    end

    test "obsolete translations are discarded (even the manually entered ones)" do
      old_po = %Messages{
        messages: [
          %Message.Singular{msgid: "obs_auto", msgstr: "foo", flags: @autogenerated_flags},
          %Message.Singular{msgid: "obs_manual", msgstr: "foo"},
          %Message.Singular{msgid: "tomerge", msgstr: "foo"}
        ]
      }

      new_pot = %Messages{messages: [%Message.Singular{msgid: "tomerge", msgstr: ""}]}

      assert {%Messages{messages: [t]}, stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert t.msgid == "tomerge"
      assert t.msgstr == "foo"

      assert stats == %{exact_matches: 1, fuzzy_matches: 0, new: 0, removed: 2}
    end

    test "when translations match, the msgstr of the old one is preserved" do
      old_po = %Messages{messages: [%Message.Singular{msgid: "foo", msgstr: "bar"}]}
      new_pot = %Messages{messages: [%Message.Singular{msgid: "foo", msgstr: ""}]}

      assert {%Messages{messages: [t]}, _stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert t.msgid == "foo"
      assert t.msgstr == "bar"
    end

    test "when translations match, existing translator comments are preserved" do
      # Note that the new translation *should* not have any translator comments
      # (comes from a POT file).
      old_po = %Messages{
        messages: [
          %Message.Singular{msgid: "foo", comments: ["# existing comment"]}
        ]
      }

      new_pot = %Messages{
        messages: [
          %Message.Singular{msgid: "foo", comments: ["# new comment"]}
        ]
      }

      assert {%Messages{messages: [t]}, _stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert t.msgid == "foo"
      assert t.comments == ["# existing comment"]
    end

    test "when translations match, existing translator flags are preserved" do
      old_po = %Messages{
        messages: [%Message.Singular{msgid: "foo", flags: [["fuzzy"]]}]
      }

      new_pot = %Messages{messages: [%Message.Singular{msgid: "foo"}]}

      assert {%Messages{messages: [t]}, _stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert Message.has_flag?(t, "fuzzy")
    end

    test "when translations match, existing extracted comments are replaced by new ones" do
      old_po = %Messages{
        messages: [
          %Message.Singular{
            msgid: "foo",
            extracted_comments: ["#. existing comment", "#. other existing comment"]
          }
        ]
      }

      new_pot = %Messages{
        messages: [
          %Message.Singular{msgid: "foo", extracted_comments: ["#. new comment"]}
        ]
      }

      assert {%Messages{messages: [t]}, _stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert t.extracted_comments == ["#. new comment"]
    end

    test "when translations match, existing references are replaced by new ones" do
      old_po = %Messages{
        messages: [
          %Message.Singular{msgid: "foo", references: [{"foo.ex", 1}]}
        ]
      }

      new_pot = %Messages{
        messages: [
          %Message.Singular{msgid: "foo", references: [{"bar.ex", 1}]}
        ]
      }

      assert {%Messages{messages: [t]}, _stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert t.references == [{"bar.ex", 1}]
    end

    test "when translations match, existing flags are replaced by new ones" do
      old_po = %Messages{messages: [%Message.Singular{msgid: "foo"}]}

      new_pot = %Messages{
        messages: [
          %Message.Singular{msgid: "foo", flags: @autogenerated_flags}
        ]
      }

      assert {%Messages{messages: [t]}, _stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert t.flags == @autogenerated_flags
    end

    test "translations with same msgid but different msgctxt are completely different" do
      old_po = %Messages{
        messages: [
          %Message.Singular{msgid: "foo", msgstr: "no context"},
          %Message.Singular{
            msgid: "foo",
            msgctxt: "context",
            msgstr: "with context"
          }
        ]
      }

      new_pot = %Messages{
        messages: [
          %Message.Singular{msgid: "foo", msgctxt: "context", msgstr: ""},
          %Message.Singular{msgid: "foo", msgctxt: "other context", msgstr: ""},
          %Message.Singular{msgid: "foo", msgstr: ""}
        ]
      }

      assert {%Messages{messages: translations}, _stats} =
               Merger.merge(old_po, new_pot, "en", @opts)

      assert [
               %Message.Singular{msgid: "foo", msgctxt: "context", msgstr: "with context"},
               %Message.Singular{msgid: "foo", msgctxt: "other context", msgstr: "no context"} =
                 _fuzzy,
               %Message.Singular{msgid: "foo", msgstr: "no context"}
             ] = translations
    end

    test "new translations are fuzzy-matched against obsolete translations" do
      old_po = %Messages{
        messages: [
          %Message.Singular{
            msgid: "hello world!",
            msgstr: ["foo"],
            comments: ["# existing comment"],
            extracted_comments: ["#. existing comment"],
            references: [{"foo.ex", 1}]
          }
        ]
      }

      new_pot = %Messages{
        messages: [
          %Message.Singular{
            msgid: "hello worlds!",
            references: [{"foo.ex", 2}],
            extracted_comments: ["#. new comment"],
            flags: [["my-flag"]]
          }
        ]
      }

      assert {%Messages{messages: [t]}, stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert stats == %{exact_matches: 0, fuzzy_matches: 1, new: 0, removed: 0}

      assert t.msgid == "hello worlds!"
      assert t.msgstr == ["foo"]
      assert t.comments == ["# existing comment"]
      assert t.extracted_comments == ["#. new comment"]
      assert t.references == [{"foo.ex", 2}]
      assert t.flags == [["my-flag", "fuzzy"]]
    end

    test "exact matches have precedence over fuzzy matches" do
      old_po = %Messages{
        messages: [
          %Message.Singular{msgid: ["hello world!"], msgstr: ["foo"]},
          %Message.Singular{msgid: ["hello worlds!"], msgstr: ["bar"]}
        ]
      }

      new_pot = %Messages{
        messages: [%Message.Singular{msgid: ["hello world!"]}]
      }

      # Let's check that the "hello worlds!" translation is discarded even if it's
      # a fuzzy match for "hello world!".
      assert {%Messages{messages: [t]}, stats} = Merger.merge(old_po, new_pot, "en", @opts)

      refute Message.has_flag?(t, "fuzzy")
      assert t.msgid == ["hello world!"]
      assert t.msgstr == ["foo"]

      assert stats == %{exact_matches: 1, fuzzy_matches: 0, new: 0, removed: 1}
    end

    test "exact matches do not prevent fuzzy matches for other translations" do
      old_po = %Messages{
        messages: [%Message.Singular{msgid: ["hello world"], msgstr: ["foo"]}]
      }

      # "hello world" will match exactly.
      # "hello world!" should still get a fuzzy match.
      new_pot = %Messages{
        messages: [
          %Message.Singular{msgid: ["hello world"]},
          %Message.Singular{msgid: ["hello world!"]}
        ]
      }

      assert {%Messages{messages: [t1, t2]}, stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert t1.msgid == ["hello world"]
      assert t1.msgstr == ["foo"]
      refute Message.has_flag?(t1, "fuzzy")

      assert t2.msgid == ["hello world!"]
      assert t2.msgstr == ["foo"]
      assert Message.has_flag?(t2, "fuzzy")

      assert stats.new == 0
      assert stats.removed == 0
      assert stats.fuzzy_matches == 1
      assert stats.exact_matches == 1
    end

    test "multiple translations can fuzzy match against a single translation" do
      old_po = %Messages{
        messages: [%Message.Singular{msgid: ["hello world"], msgstr: ["foo"]}]
      }

      new_pot = %Messages{
        messages: [
          %Message.Singular{msgid: ["hello world 1"]},
          %Message.Singular{msgid: ["hello world 2"]}
        ]
      }

      assert {%Messages{messages: [t1, t2]}, stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert t1.msgid == ["hello world 1"]
      assert t1.msgstr == ["foo"]
      assert Message.has_flag?(t1, "fuzzy")

      assert t2.msgid == ["hello world 2"]
      assert t2.msgstr == ["foo"]
      assert Message.has_flag?(t2, "fuzzy")

      assert stats == %{exact_matches: 0, new: 0, fuzzy_matches: 2, removed: 0}
    end

    test "filling in a fuzzy translation preserves references" do
      old_po = %Messages{
        messages: [
          %Message.Singular{
            msgid: ["hello world!"],
            msgstr: ["foo"],
            comments: ["# old comment"],
            references: [{"old_file.txt", 1}]
          }
        ]
      }

      new_pot = %Messages{
        messages: [
          %Message.Singular{
            msgid: ["hello worlds!"],
            references: [{"new_file.txt", 2}]
          }
        ]
      }

      assert {%Messages{messages: [t]}, _stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert Message.has_flag?(t, "fuzzy")
      assert t.msgid == ["hello worlds!"]
      assert t.msgstr == ["foo"]
      assert t.comments == ["# old comment"]
      assert t.references == [{"new_file.txt", 2}]
    end

    test "simple translations can be a fuzzy match for plurals" do
      old_po = %Messages{
        messages: [
          %Message.Singular{
            msgid: ["Here are {count} cocoa balls."],
            msgstr: ["Hier sind {count} Kakaokugeln."],
            comments: ["# Guyanese Cocoballs"],
            references: [{"old_file.txt", 1}]
          }
        ]
      }

      new_pot = %Messages{
        messages: [
          %Message.Plural{
            msgid: ["Here is a cocoa ball."],
            msgid_plural: ["Here are {count} cocoa balls."],
            references: [{"new_file.txt", 2}]
          }
        ]
      }

      assert {%Messages{messages: [t]}, stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert Message.has_flag?(t, "fuzzy")
      assert t.msgid == ["Here is a cocoa ball."]
      assert t.msgid_plural == ["Here are {count} cocoa balls."]
      assert t.msgstr[0] == ["Hier sind {count} Kakaokugeln."]
      assert t.comments == ["# Guyanese Cocoballs"]
      assert t.references == [{"new_file.txt", 2}]

      assert stats == %{exact_matches: 0, fuzzy_matches: 1, new: 0, removed: 0}
    end

    # This has been verified with msgmerge too.
    test "translations fuzzy-match regardless of msgctxt" do
      old_po = %Messages{
        messages: [
          %Message.Singular{msgid: "hello world!", msgctxt: "context", msgstr: ["cfoo"]}
        ]
      }

      new_pot = %Messages{
        messages: [
          %Message.Singular{
            msgid: "hello worlds!",
            msgctxt: "completely different"
          },
          %Message.Singular{msgid: "different", msgctxt: "context"}
        ]
      }

      assert {%Messages{messages: [fuzzy_t, new_t]}, stats} =
               Merger.merge(old_po, new_pot, "en", @opts)

      assert stats == %{exact_matches: 0, fuzzy_matches: 1, new: 1, removed: 0}

      assert fuzzy_t.msgid == "hello worlds!"
      assert fuzzy_t.msgstr == ["cfoo"]
      assert fuzzy_t.msgctxt == "completely different"
      assert fuzzy_t.flags == [["fuzzy"]]

      assert new_t.msgid == "different"
      assert new_t.msgctxt == "context"
    end

    test "if there's a Plural-Forms header, it's used to determine number of plural forms" do
      old_po = %Messages{
        headers: [~s(Plural-Forms:  nplurals=3)],
        messages: []
      }

      new_pot = %Messages{
        messages: [
          %Message.Singular{msgid: "a"},
          %Message.Plural{msgid: "b", msgid_plural: "bs"}
        ]
      }

      assert {%Messages{messages: [t, pt]}, _stats} = Merger.merge(old_po, new_pot, "en", @opts)

      assert t.msgid == "a"

      assert pt.msgid == "b"
      assert pt.msgid_plural == "bs"
      assert pt.msgstr == %{0 => [""], 1 => [""], 2 => [""]}
    end

    test "plural forms can be specified as an option" do
      old_po = %Messages{messages: []}

      new_pot = %Messages{
        messages: [
          %Message.Singular{msgid: "a"},
          %Message.Plural{msgid: "b", msgid_plural: "bs"}
        ]
      }

      opts = [plural_forms: 1] ++ @opts

      assert {%Messages{messages: [t, pt]}, _stats} = Merger.merge(old_po, new_pot, "en", opts)

      assert t.msgid == "a"

      assert pt.msgid == "b"
      assert pt.msgid_plural == "bs"
      assert pt.msgstr == %{0 => [""]}
    end
  end

  test "new_po_file/2" do
    pot_path = Path.join(@pot_path, "new_po_file.pot")
    new_po_path = Path.join(@pot_path, "it/LC_MESSAGES/new_po_file.po")

    write_file(pot_path, """
    ## Stripme!
    # A comment
    msgid "foo"
    msgstr "bar"

    msgid "plural"
    msgid_plural "plurals"
    msgstr[0] ""
    msgstr[1] ""

    msgctxt "my_context"
    msgid "with context"
    msgstr ""
    """)

    {new_po, _stats} = Merger.new_po_file(new_po_path, pot_path, "it", [plural_forms: 1] ++ @opts)

    assert new_po.file == new_po_path
    assert new_po.headers == ["", "Language: it\n", "Plural-Forms: nplurals=1\n"]

    assert ["# \"msgid\"s in this file come from POT (.pot) files.", "##" | _] =
             new_po.top_comments

    assert [%Message.Singular{} = t, %Message.Plural{} = pt, %Message.Singular{} = ct] =
             new_po.messages

    assert t.comments == [" A comment"]
    assert t.msgid == ["foo"]
    assert t.msgstr == ["bar"]

    assert pt.msgid == ["plural"]
    assert pt.msgid_plural == ["plurals"]
    assert pt.msgstr == %{0 => [""]}

    assert ct.msgctxt == ["my_context"]
    assert ct.msgid == ["with context"]
  end

  defp write_file(path, contents) do
    path |> Path.dirname() |> File.mkdir_p!()
    File.write!(path, contents)
  end
end
